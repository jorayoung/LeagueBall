<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="logo.png" type="image/png">
    <title>LeagueBall</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #1a2a6c, #b21f1f, #fdbb2d);
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            color: white;
        }

        .game-container {
            position: relative;
            width: 800px;
            height: 500px;
        }

        #gameCanvas {
            background: linear-gradient(#2c3e50, #4a6491);
            border: 5px solid #34495e;
            border-radius: 10px;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
        }

        .ui-overlay {
    position: absolute;
    top: -100px; /* Поднимаем оверлей выше поля */
    left: 0;
    width: 100%;
    height: auto;
    pointer-events: none;
    z-index: 10;
}

.score {
    position: absolute;
    top: 20px;
    font-size: 48px;
    font-weight: bold;
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
}

#redScore {
    left: 35%; /* Немного сдвигаем для лучшего позиционирования */
    color: #ff4757;
}

#blueScore {
    right: 35%; /* Немного сдвигаем для лучшего позиционирования */
    color: #3742fa;
}

.timer {
    position: absolute;
    top: 30px;
    left: 50%;
    transform: translateX(-50%);
    font-size: 36px;
    font-weight: bold;
    background: rgba(0, 0, 0, 0.7);
    padding: 8px 20px;
    border-radius: 25px;
    text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7);
    border: 2px solid rgba(255, 255, 255, 0.2);
}

.goal-animation {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 72px;
    font-weight: bold;
    color: gold;
    text-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
    opacity: 0;
    pointer-events: none;
    animation: goalPulse 2s ease-out;
    z-index: 20;
}

        @keyframes goalPulse {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
            20% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
            40% { transform: translate(-50%, -50%) scale(1); }
            80% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(1.5); }
        }

        .menu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 255, 255, 0.1);
        }

        .menu h1 {
            margin-bottom: 20px;
            color: #fdbb2d;
            text-shadow: 0 0 10px rgba(253, 187, 45, 0.5);
        }

        .team-select {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 20px 0;
        }

        .team-btn {
            padding: 15px 30px;
            font-size: 18px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
        }

        #redTeam {
            background: linear-gradient(to bottom, #ff4757, #c23616);
            color: white;
        }

        #blueTeam {
            background: linear-gradient(to bottom, #3742fa, #192a56);
            color: white;
        }

        .team-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .controls {
            margin-top: 20px;
            font-size: 14px;
            color: #ddd;
        }

        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            display: none;
            backdrop-filter: blur(10px);
            border: 2px solid gold;
        }

        .game-over h2 {
            color: gold;
            margin-bottom: 20px;
        }

        .restart-btn {
            padding: 12px 25px;
            font-size: 16px;
            background: linear-gradient(to bottom, #00b894, #00806a);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .restart-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

/* Стили для кнопки "Об игре" */
.about-btn {
    margin-top: 20px;
    padding: 12px 24px;
    font-size: 16px;
    font-weight: bold;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    border: none;
    border-radius: 25px;
    cursor: pointer;
    transition: all 0.3s ease;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
    z-index: 20;
    pointer-events: auto;
    display: block;
    margin-left: auto;
    margin-right: auto;
}

.about-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
    background: linear-gradient(135deg, #764ba2 0%, #667eea 100%);
}

.about-btn:active {
    transform: translateY(0);
}

/* Модальное окно "Об игре" */
.about-modal {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 600px;
    max-height: 80vh;
    background: rgba(0, 0, 0, 0.95);
    border-radius: 15px;
    padding: 30px;
    backdrop-filter: blur(10px);
    border: 2px solid rgba(255, 255, 255, 0.1);
    box-shadow: 0 0 50px rgba(0, 0, 0, 0.8);
    display: none;
    z-index: 100;
    overflow-y: auto;
    color: white;
}

.about-content {
    position: relative;
}

.close-btn {
    position: absolute;
    top: -20px;
    right: -10px;
    background: linear-gradient(135deg, #ff4757, #c23616);
    color: white;
    border: none;
    border-radius: 50%;
    width: 35px;
    height: 35px;
    font-size: 20px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.3s ease;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
}

.close-btn:hover {
    background: linear-gradient(135deg, #c23616, #ff4757);
    transform: scale(1.1);
    box-shadow: 0 3px 12px rgba(0, 0, 0, 0.4);
}

.about-section {
    margin-bottom: 25px;
}

.about-section h2 {
    color: #fdbb2d;
    margin-bottom: 15px;
    text-shadow: 0 0 10px rgba(253, 187, 45, 0.5);
    border-bottom: 2px solid rgba(253, 187, 45, 0.3);
    padding-bottom: 5px;
}

.about-section p {
    line-height: 1.6;
    margin-bottom: 10px;
    color: #ddd;
}

.about-section ul {
    list-style: none;
    padding-left: 20px;
}

.about-section li {
    margin-bottom: 8px;
    position: relative;
}

.about-section li:before {
    content: "•";
    color: #fdbb2d;
    font-weight: bold;
    display: inline-block;
    width: 1em;
    margin-left: -1em;
}

.links {
    display: flex;
    justify-content: center;
    gap: 15px;
    margin-top: 10px;
    flex-wrap: wrap;
}

.link-btn {
    padding: 10px 20px;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    text-decoration: none;
    border-radius: 25px;
    transition: all 0.3s ease;
    display: inline-block;
    font-weight: bold;
    text-align: center;
    min-width: 120px;
}

.link-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
    background: linear-gradient(135deg, #764ba2 0%, #667eea 100%);
}

/* Затемнение фона */
.overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.7);
    backdrop-filter: blur(5px);
    display: none;
    z-index: 90;
}

/* Стили для модальных окон */
.modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.8);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1000;
    backdrop-filter: blur(5px);
}

.modal-content {
    background: linear-gradient(135deg, #1a2a6c, #b21f1f);
    padding: 30px;
    border-radius: 15px;
    text-align: center;
    width: 500px;
    max-width: 90%;
    box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
    border: 2px solid gold;
}

.modal h2 {
    color: #fdbb2d;
    margin-bottom: 20px;
    text-shadow: 0 0 10px rgba(253, 187, 45, 0.5);
}

.team-name-input {
    width: 100%;
    padding: 15px;
    font-size: 18px;
    border: 2px solid #fdbb2d;
    border-radius: 10px;
    background: rgba(0, 0, 0, 0.7);
    color: white;
    text-align: center;
    margin-bottom: 20px;
}

.team-name-input:focus {
    outline: none;
    border-color: #ff6b6b;
    box-shadow: 0 0 10px rgba(255, 107, 107, 0.5);
}

.color-picker {
    display: grid;
    grid-template-columns: repeat(5, 1fr);
    gap: 10px;
    margin: 20px 0;
}

.color-option {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    cursor: pointer;
    border: 3px solid transparent;
    transition: all 0.3s ease;
    margin: 0 auto;
}

.color-option:hover {
    transform: scale(1.2);
    border-color: white;
}

.color-option.selected {
    border-color: gold;
    box-shadow: 0 0 15px gold;
}

.submit-btn {
    padding: 12px 30px;
    font-size: 18px;
    background: linear-gradient(to bottom, #00b894, #00806a);
    color: white;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.3s ease;
    margin-top: 20px;
}

.submit-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
}

/* Стили для турнирных модальных окон */
.tournament-modal {
    text-align: center;
}

.tournament-matchup {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 30px;
    margin: 30px 0;
}

.tournament-team {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 10px;
}

.tournament-vs {
    font-size: 24px;
    font-weight: bold;
    color: #fdbb2d;
}

.team-logo {
    width: 80px;
    height: 80px;
    border-radius: 50%;
    background-size: cover;
    background-position: center;
    border: 3px solid gold;
    box-shadow: 0 0 15px rgba(255, 215, 0, 0.5);
}

.team-name {
    font-weight: bold;
    font-size: 16px;
    color: white;
}
    </style>
</head>
<body>
    <div class="game-container">
        <canvas id="gameCanvas" width="800" height="500"></canvas>
        
        <div class="ui-overlay">
            <div id="redScore" class="score">0</div>
            <div id="blueScore" class="score">0</div>
            <div id="timer" class="timer">3:00</div>
            <div id="goalAnimation" class="goal-animation">ГОООЛ!</div>
        </div>

        <div id="teamMenu" class="menu">
            <h1>LeagueBall</h1>
            <p>Выбери сторону:</p>
            <div class="team-select">
                <button id="redTeam" class="team-btn">Слева</button>
                <button id="blueTeam" class="team-btn">Справа</button>
            </div>
<button id="aboutBtn" class="about-btn">Об игре</button>
<div id="aboutModal" class="about-modal">
    <div class="about-content">
        <button class="close-btn">&times;</button>
        
        <div class="about-section">
            <h2>🎮 Управление</h2>
            <ul>
                <li><strong>WASD</strong> - движение игрока</li>
                <li><strong>ПРОБЕЛ</strong> - удар по мячу</li>
                <li><strong>Q</strong> - попросить пас</li>
            </ul>
        </div>

        <div class="about-section">
            <h2>🏆 Правила игры</h2>
            <p>Забейте больше голов, чем команда противника за 3 минуты!</p>
            <p>При ничьей начинается овертайм до первого гола (золотой гол).</p>
        </div>

        <div class="about-section">
            <h2>💡 Советы</h2>
<ul>
        <li><strong>Полноэкранный режим</strong> - для лучшего погружения нажмите F11</li>
        <li><strong>Масштабирование</strong> - регулируйте приближение Ctrl + +/-</li>
        <li><strong>Командная игра</strong> - используйте Q чтобы получить точный пас</li>
        <li><strong>Игра без мяча</strong> - занимайте выгодные позиции и вызывайте пас когда свободны</li>
        <li><strong>Оборона</strong> - Занимайте выгодные позиции, закрывайте соперников и перехватывайте пасы</li>
        <li><strong>Позиционка</strong> - Вовремя открывайтесь под пас если союзника пресингуют</li>
        <li><strong>Выбор</strong> - Ты можешь быть хоть вратарём, хоть опорником, хоть нападающим, ты сам решаешь с каким темпом будет идти игра</li>
</ul>
        </div>

        <div class="about-section">
            <h2>🔗 Ссылки</h2>
            <div class="links">
                <a href="https://github.com/jorayoung" class="link-btn">GitHub</a>
                <a href="https://www.youtube.com/channel/UC8-FsZ4oaW4k0Tlydl54lmg/featured" class="link-btn">YouTube</a>
                <a href="https://t.me/NoStuff_haxball" class="link-btn">Телеграм канал</a>
                <a href="https://t.me/jorayoung761" class="link-btn">Телеграм разработчика</a>
                <a href="https://vk.com/coraline161" class="link-btn">Вк разработчика</a>
            </div>
        </div>

        <div class="about-section">
            <h2>ℹ️ О проекте</h2>
            <p>LeagueBall - футбольный аркадный симулятор, погрузись в командную игру с ИИ игроками, стань главной сенсацией турнира.</p>
            <p>Версия: 1.0 | Разработчик: Jora young</p>
        </div>
    </div>
</div>
<div id="overlay" class="overlay"></div>
        </div>

        <div id="gameOver" class="game-over">
            <h2>ИГРА ОКОНЧЕНА!</h2>
            <p>Финальный счет: <span id="finalScore">0 - 0</span></p>
            <button id="restartBtn" class="restart-btn">Играть снова</button>
        </div>
    </div>


<!-- Звуковые элементы -->
<audio id="kickSound" src="kick.mp3" preload="auto"></audio>
<audio id="goalSound" src="goal.mp3" preload="auto"></audio>

<!-- Модальное окно для названия команды -->
<div id="teamNameModal" class="modal" style="display: flex;">
    <div class="modal-content">
        <h2>Введите название вашей команды</h2>
        <input type="text" id="teamNameInput" class="team-name-input" placeholder="Легендарные чемпионы" maxlength="20">
        <button id="teamNameSubmit" class="submit-btn">Продолжить</button>
    </div>
</div>

<!-- Модальное окно для выбора цвета -->
<div id="colorModal" class="modal" style="display: none;">
    <div class="modal-content">
        <h2>Выберите цвет вашей команды</h2>
        <div class="color-picker">
            <div class="color-option" data-color="#ff4757" style="background: #ff4757;"></div>
            <div class="color-option" data-color="#3742fa" style="background: #3742fa;"></div>
            <div class="color-option" data-color="#000000" style="background: #000000;"></div>
            <div class="color-option" data-color="#ffa502" style="background: #ffa502;"></div>
            <div class="color-option" data-color="#a55eea" style="background: #a55eea;"></div>
            <div class="color-option" data-color="#fd79a8" style="background: #fd79a8;"></div>
            <div class="color-option" data-color="#fdcb6e" style="background: #fdcb6e;"></div>
            <div class="color-option" data-color="#00cec9" style="background: #00cec9;"></div>
            <div class="color-option" data-color="#6c5ce7" style="background: #6c5ce7;"></div>
            <div class="color-option" data-color="#dfe6e9" style="background: #dfe6e9;"></div>
            <div class="color-option" data-color="#e17055" style="background: #e17055;"></div>
            <div class="color-option" data-color="#0984e3" style="background: #0984e3;"></div>
            <div class="color-option" data-color="#b2bec3" style="background: #b2bec3;"></div>
            <div class="color-option" data-color="#00d2d3" style="background: #00d2d3;"></div>
            <div class="color-option" data-color="#5f27cd" style="background: #5f27cd;"></div>
        </div>
        <button id="colorSubmit" class="submit-btn">Начать игру</button>
    </div>
</div>
    <script>
        // Конфигурация игры
        const config = {
            width: 800,
            height: 500,
            playerRadius: 13,
            ballRadius: 8,
            goalWidth: 100,
            goalHeight: 150,
            playerSpeed: 4.0,
            kickPower: 8,
            friction: 0.98,
            ballFriction: 0.99,
            ballAfkThreshold: 3000,
            playerBallInteraction: 0.3, // Уменьшено для более плавного ведения
            ballControlDistance: 25, // Дистанция контроля мяча
            goalCooldown: 150, // Задержка после гола, чтобы избежать множественных голов
            ballLastMoveTime: 0,
	    ballLastX: 0,
            ballLastY: 0,
        };


const botConfig = {
    speed: 3.9,
    reactionTime: 0.8,
    kickPower: 8,
    ballControl: 0.4, // Сила контроля мяча для ботов
    positioning: {
        goalkeeper: { x: 100, y: config.height / 2 },
        defender: { x: config.width / 3, y: config.height / 2 },
        attacker: { x: config.width * 2 / 3, y: config.height / 2 }
    }
};

// Боты
let redBots = [];
let blueBots = [];

// Данные турнира
const tournamentData = {
    stages: [
        {
            name: "1/16 финала",
            teams: [
                { name: "Ростов", logo: "rostov.png", colors: ["#e2d512", "#09224e"] },
                { name: "Зенит", logo: "zenit.png", colors: ["#00A9E0", "#004C97"] },
                { name: "Сантос", logo: "santos.png", colors: ["#000000", "#FFFFFF"] },
                { name: "Динамо", logo: "dinamo.png", colors: ["#FFFFFF", "#005BBB"] },
                { name: "ЦСКА", logo: "cska.png", colors: ["#BD0000", "#2300BD"] },
                { name: "Фенербахче", logo: "fener.png", colors: ["#EDF500", "#2300BD"] },
                { name: "Бешикташ", logo: "besiktash.png", colors: ["#000000", "#FFFFFF"] },
                { name: "Селтик", logo: "seltic.png", colors: ["#006437", "#FFFFFF"] },
                { name: "Брюгге", logo: "brugge.png", colors: ["#004994", "#000000"] },
                { name: "Айнтрахт", logo: "antraht.png", colors: ["#000000", "#FFFFFF"] },
                { name: "Спартак", logo: "spartak.png", colors: ["#DC052D", "#FFFFFF"] },
                { name: "Локомотив", logo: "loko.png", colors: ["#005C18", "#AD0000"] },
                { name: "Краснодар", logo: "krasnodar.png", colors: ["#005C18", "#002909"] },
                { name: "Рубин", logo: "rubin.png", colors: ["#870000", "#290000"] },
                { name: "Шахтёр", logo: "shahter.png", colors: ["#FF6A00", "#000000"] },
                { name: "Динамо Минск", logo: "minsk.png", colors: ["#FFFFFF", "#85F5FF"] },
                { name: "Кайрат", logo: "kairat.png", colors: ["#F0FF00", "#000000"] },
                { name: "Комо", logo: "como.png", colors: ["#66E9FF", "#FFFFFF"] },
                { name: "Вальядолид", logo: "valhadolid.png", colors: ["#9300BF", "#69008A"] },
                { name: "Ренн", logo: "renn.png", colors: ["#C40000", "#000000"] },
                { name: "Хофенхайм", logo: "hof.png", colors: ["#2E53FF", "#000000"] },
            ]
        },
        {
            name: "1/8 финала",
            teams: [
                { name: "Спортинг", logo: "sporting.png", colors: ["#006437", "#FFFFFF"] },
                { name: "Аякс", logo: "ajax.png", colors: ["#D2122E", "#FFFFFF"] },
                { name: "Боруссия Дортмунд", logo: "dortmund.png", colors: ["#FDE100", "#000000"] },
                { name: "Порту", logo: "portu.png", colors: ["#FFFFFF", "#005BBB"] },
                { name: "Фиорентина", logo: "fiorentina.png", colors: ["#6700B8", "#3E0070"] },
                { name: "Лацио", logo: "lazio.png", colors: ["#66C2FF", "#A6DCFF"] },
                { name: "Галатасарай", logo: "galo.png", colors: ["#DB9900", "#7D0300"] },
            ]
        },
        {
            name: "1/4 финала",
            teams: [
                { name: "Бавария", logo: "bayern.png", colors: ["#DC052D", "#FFFFFF"] },
                { name: "Арсенал", logo: "arsenal.png", colors: ["#EF0107", "#FFFFFF"] },
                { name: "Ньюкасл Юнайтед", logo: "newcastle.png", colors: ["#241F20", "#FFFFFF"] },
                { name: "Тоттенхем", logo: "tottenham.png", colors: ["#FFFFFF", "#000026"] },
                { name: "Наполи", logo: "napoli.png", colors: ["#089DFF", "#007ECF"] },
                { name: "Аталанта", logo: "atalanta.png", colors: ["#0000B3", "#000000"] },
                { name: "Милан", logo: "milan.png", colors: ["#B30000", "#000000"] },
            ]
        },
        {
            name: "1/2 финала",
            teams: [
                { name: "Атлетико Мадрид", logo: "atletico.png", colors: ["#CB3524", "#0C2340"] },
                { name: "Челси", logo: "chelsea.png", colors: ["#034694", "#FFFFFF"] },
                { name: "Манчестер Юнайтед", logo: "manutd.png", colors: ["#DA291C", "#e10505"] },
                { name: "Манчестер Сити", logo: "manc.png", colors: ["#8ADAFF", "#D9F4FF"] },
                { name: "Интер", logo: "inter.png", colors: ["#004994", "#000000"] },
            ]
        },
        {
            name: "Финал",
            teams: [
                { name: "Реал Мадрид", logo: "realmadrid.png", colors: ["#FFFFFF", "#000000"] },
                { name: "Ливерпуль", logo: "liverpool.png", colors: ["#C8102E", "#FFFFFF"] },
                { name: "Барселона", logo: "barcelona.png", colors: ["#A50044", "#004D98"] },
                { name: "ПСЖ", logo: "psg.png", colors: ["#001345", "#BA0000"] },
            ]
        }
    ]
};

// Уровни сложности ботов для каждого этапа турнира
const difficultyLevels = {
    0: { // 1/16 финала - базовый уровень (как сейчас)
        speedMultiplier: 1.0,
        kickPowerMultiplier: 1.0,
        reactionMultiplier: 1.0,
        errorChance: 0.4, // 40% шанс ошибки
        passAccuracy: 0.6 // 60% точность пасов
    },
    1: { // 1/8 финала - на 15% лучше
        speedMultiplier: 1.15,
        kickPowerMultiplier: 1.15,
        reactionMultiplier: 1.15,
        errorChance: 0.3,
        passAccuracy: 0.7
    },
    2: { // 1/4 финала - еще лучше
        speedMultiplier: 1.25,
        kickPowerMultiplier: 1.25,
        reactionMultiplier: 1.3,
        errorChance: 0.2,
        passAccuracy: 0.8
    },
    3: { // 1/2 финала - почти профессионалы
        speedMultiplier: 1.4,
        kickPowerMultiplier: 1.4,
        reactionMultiplier: 1.7,
        errorChance: 0.1,
        passAccuracy: 0.9
    },
    4: { // Финал - максимальная сложность
        speedMultiplier: 1.6,
        kickPowerMultiplier: 1.6,
        reactionMultiplier: 2.0,
        errorChance: 0.01, // почти не ошибаются
        passAccuracy: 0.99 // точные пасы
    }
};


        // Состояние игры
        let gameState = {
            running: false,
            redScore: 0,
            blueScore: 0,
            timeLeft: 180,
            playerTeam: 'red',
            goalAnimation: false,
            animationTimer: 0,
            goalJustScored: false, // Флаг, что гол только что забит
            goalCooldown: 0, // Таймер задержки после гола
            isOvertime: false,
            isGoldenGoal: false,
            overtimeStarted: false,
tournament: {
        active: false,
        currentStage: 0,
        playerTeam: null,
        opponentTeam: null,
        stageCompleted: false
    }
        };

        // Игровые объекты
        let player = {
            x: config.width / 2,
            y: config.height / 2,
            vx: 0,
            vy: 0,
            kicking: false,
            kickCooldown: 0,
            hasBall: false // Флаг, что игрок контролирует мяч
        };



        let ball = {
            x: config.width / 2,
            y: config.height / 2,
            vx: 0,
            vy: 0
        };

        // Элементы DOM
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const redScoreElem = document.getElementById('redScore');
        const blueScoreElem = document.getElementById('blueScore');
        const timerElem = document.getElementById('timer');
        const goalAnimationElem = document.getElementById('goalAnimation');
        const teamMenu = document.getElementById('teamMenu');
        const gameOverElem = document.getElementById('gameOver');
        const finalScoreElem = document.getElementById('finalScore');
        const restartBtn = document.getElementById('restartBtn');

        // Клавиши управления
        const keys = {
            w: false,
            a: false,
            s: false,
            d: false,
            space: false,
            q: false
        };

        // Обработчики событий
        document.addEventListener('keydown', (e) => {
            const key = e.code.toLowerCase();
            if (key === 'keyw') keys.w = true;
            if (key === 'keya') keys.a = true;
            if (key === 'keys') keys.s = true;
            if (key === 'keyd') keys.d = true;
            if (key === 'space') keys.space = true;
            if (key === 'keyq') keys.q = true;
        });

        document.addEventListener('keyup', (e) => {
            const key = e.code.toLowerCase();
            if (key === 'keyw') keys.w = false;
            if (key === 'keya') keys.a = false;
            if (key === 'keys') keys.s = false;
            if (key === 'keyd') keys.d = false;
            if (key === 'space') keys.space = false;
            if (key === 'keyq') keys.q = false;
        });

// Выбор команды
document.getElementById('redTeam').addEventListener('click', () => {
    gameState.playerTeam = 'red';
    startTournament(); // Заменяем startGame() на startTournament()
});

document.getElementById('blueTeam').addEventListener('click', () => {
    gameState.playerTeam = 'blue';
    startTournament(); // Заменяем startGame() на startTournament()
});

        // Рестарт игры
        restartBtn.addEventListener('click', () => {
            gameOverElem.style.display = 'none';
            teamMenu.style.display = 'block';
            resetGame();
        });

        function startGame() {
    teamMenu.style.display = 'none';
    gameState.running = true;
    
    // Сбрасываем состояние игры для нового матча
    gameState.redScore = 0;
    gameState.blueScore = 0;
    gameState.timeLeft = 180;
    gameState.isOvertime = false;
    gameState.isGoldenGoal = false;
    gameState.overtimeStarted = false;
    
    // Обновляем UI
    redScoreElem.textContent = '0';
    blueScoreElem.textContent = '0';
    timerElem.textContent = '3:00';
    timerElem.style.display = 'block';
    
    // Скрываем надпись "ДО ЗГ" если она есть
    if (document.getElementById('goldenGoalText')) {
        document.getElementById('goldenGoalText').style.display = 'none';
    }
    
    resetPositions();
    initBots();
    gameLoop();
}

// Функция для начала турнира
function startTournament() {
    gameState.tournament.active = true;
    gameState.tournament.currentStage = 0;
    gameState.tournament.stageCompleted = false;
    selectRandomOpponent();
    showTournamentModal();
}

// Функция для выбора случайного соперника
function selectRandomOpponent() {
    const currentStage = tournamentData.stages[gameState.tournament.currentStage];
    const randomIndex = Math.floor(Math.random() * currentStage.teams.length);
    gameState.tournament.opponentTeam = currentStage.teams[randomIndex];
}

// Функция для получения текущих параметров сложности
function getCurrentDifficulty() {
    const stageIndex = gameState.tournament.currentStage;
    return difficultyLevels[stageIndex] || difficultyLevels[0];
}

// Функция для отрисовки игроков с двухцветной формой
function drawTwoColorPlayer(x, y, radius, topColor, bottomColor) {
    // Верхняя половина
    ctx.fillStyle = topColor;
    ctx.beginPath();
    ctx.arc(x, y, radius, Math.PI, 0, false);
    ctx.fill();
    
    // Нижняя половина
    ctx.fillStyle = bottomColor;
    ctx.beginPath();
    ctx.arc(x, y, radius, 0, Math.PI, false);
    ctx.fill();
    
    // Обводка
    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(x, y, radius, 0, Math.PI * 2);
    ctx.stroke();
}


// Функция для показа модального окна турнира
function showTournamentModal() {
    const stage = tournamentData.stages[gameState.tournament.currentStage];
    const opponentColors = gameState.tournament.opponentTeam.colors;
    const difficulty = getCurrentDifficulty();
    
    // Создаем модальное окно турнира
    const tournamentModal = document.createElement('div');
    tournamentModal.className = 'modal';
    tournamentModal.innerHTML = `
        <div class="modal-content tournament-modal">
            <h2>${stage.name}</h2>
            <div class="tournament-matchup">
                <div class="tournament-team">
                    <div class="team-logo" style="background: linear-gradient(to bottom, ${teamColor}, ${teamColor})"></div>
                    <div class="team-name">${teamName}</div>
                    <div style="font-size: 12px; color: #00ff00;">★ Уровень 1</div>
                </div>
                <div class="tournament-vs">VS</div>
                <div class="tournament-team">
                    <div class="team-logo" style="background: linear-gradient(to bottom, ${opponentColors[0]}, ${opponentColors[1]})"></div>
                    <div class="team-name">${gameState.tournament.opponentTeam.name}</div>
                    <div style="font-size: 12px; color: #ff6b6b;">★ Уровень ${gameState.tournament.currentStage + 1}</div>
                </div>
            </div>
            <div style="margin: 15px 0; color: #fdbb2d; font-weight: bold;">
                Уровень сложности: ${gameState.tournament.currentStage + 1}/5
            </div>
            <div style="margin: 10px 0; padding: 10px; background: rgba(0, 0, 0, 0.3); border-radius: 8px;">
                <div style="font-size: 12px; color: #ddd; margin-bottom: 5px;">Характеристики соперника:</div>
                <div style="font-size: 11px; color: #ff6b6b;">⚡ Скорость: +${Math.round((difficulty.speedMultiplier - 1) * 100)}%</div>
                <div style="font-size: 11px; color: #ff9ff3;">💥 Сила удара: +${Math.round((difficulty.kickPowerMultiplier - 1) * 100)}%</div>
                <div style="font-size: 11px; color: #feca57;">🎯 Точность: ${Math.round(difficulty.passAccuracy * 100)}%</div>
                <div style="font-size: 11px; color: #00ff00;">✅ Ваша команда: Уровень 1</div>
            </div>
            <button id="tournamentPlayBtn" class="submit-btn">Играть</button>
        </div>
    `;
    
    document.body.appendChild(tournamentModal);
    
    // Логируем информацию о сложности
    console.log(`Начинается этап: ${stage.name}`);
    console.log(`Уровень сложности соперников: Этап ${gameState.tournament.currentStage + 1}`);
    console.log(`- Скорость соперников: x${difficulty.speedMultiplier}`);
    console.log(`- Сила удара соперников: x${difficulty.kickPowerMultiplier}`);
    console.log(`- Реакция соперников: x${difficulty.reactionMultiplier}`);
    console.log(`- Шанс ошибки соперников: ${difficulty.errorChance * 100}%`);
    console.log(`- Точность пасов соперников: ${difficulty.passAccuracy * 100}%`);
    console.log(`- Ваша команда: базовая сложность`);
    
    // Обработчик для кнопки "Играть"
    document.getElementById('tournamentPlayBtn').addEventListener('click', () => {
        document.body.removeChild(tournamentModal);
        startGame();
    });
}

// Функция для обработки результата матча
function handleMatchResult(isWin) {
    if (!gameState.tournament.active) return;
    
    if (isWin) {
        // Игрок победил - переходим на следующий этап
        gameState.tournament.currentStage++;
        
        if (gameState.tournament.currentStage >= tournamentData.stages.length) {
            // Турнир пройден!
            showTournamentWinModal();
            gameState.tournament.active = false;
        } else {
            // Переходим на следующий этап
            gameState.tournament.stageCompleted = true;
            selectRandomOpponent();
            
            // ПЕРЕСОЗДАЕМ БОТОВ С НОВЫМ УРОВНЕМ СЛОЖНОСТИ
            initBots();
            
            // Небольшая задержка перед показом следующего модального окна
            setTimeout(() => {
                showTournamentModal();
            }, 1000);
        }
    } else {
        // Игрок проиграл - вылет из турнира
        showTournamentLossModal();
        gameState.tournament.active = false;
        
        // Сбрасываем ботов к базовому уровню сложности на случай новой игры
        setTimeout(() => {
            initBots();
        }, 1000);
    }
    
    // Сбрасываем флаги овертайма
    gameState.isOvertime = false;
    gameState.isGoldenGoal = false;
    gameState.overtimeStarted = false;
    
    // Скрываем надпись "ДО ЗГ" если она есть
    if (document.getElementById('goldenGoalText')) {
        document.getElementById('goldenGoalText').style.display = 'none';
    }
    
    // Восстанавливаем таймер для следующего матча
    timerElem.style.display = 'block';
    
    // Логируем результат для отладки
    const stageName = tournamentData.stages[gameState.tournament.currentStage - (isWin ? 0 : 1)]?.name || "Завершен";
    console.log(`Матч ${isWin ? 'выигран' : 'проигран'} на этапе: ${stageName}`);
    console.log(`Текущий уровень сложности: ${gameState.tournament.currentStage}/5`);
}

// Функция для показа окна победы в турнире
function showTournamentWinModal() {
    const winModal = document.createElement('div');
    winModal.className = 'modal';
    winModal.innerHTML = `
        <div class="modal-content">
            <h2>🏆 ПОБЕДА В ТУРНИРЕ!</h2>
            <p>Вы стали чемпионом турнира!</p>
            <button id="tournamentRestartBtn" class="submit-btn">Завершить</button>
        </div>
    `;
    
    document.body.appendChild(winModal);
    
    document.getElementById('tournamentRestartBtn').addEventListener('click', () => {
        document.body.removeChild(winModal);
    });
}

// Функция для логирования текущего уровня сложности
function logDifficultyLevel() {
    const difficulty = getCurrentDifficulty();
    console.log(`Текущий уровень сложности: Этап ${gameState.tournament.currentStage + 1}`);
    console.log(`- Скорость: x${difficulty.speedMultiplier}`);
    console.log(`- Сила удара: x${difficulty.kickPowerMultiplier}`);
    console.log(`- Реакция: x${difficulty.reactionMultiplier}`);
    console.log(`- Шанс ошибки: ${difficulty.errorChance * 100}%`);
    console.log(`- Точность пасов: ${difficulty.passAccuracy * 100}%`);
}

// Функция для показа окна проигрыша в турнире
function showTournamentLossModal() {
    const lossModal = document.createElement('div');
    lossModal.className = 'modal';
    lossModal.innerHTML = `
        <div class="modal-content">
            <h2>😔 ВЫЛЕТ ИЗ ТУРНИРА</h2>
            <p>Вы проиграли в ${tournamentData.stages[gameState.tournament.currentStage].name}</p>
            <button id="tournamentLossBtn" class="submit-btn">Завершить</button>
        </div>
    `;
    
    document.body.appendChild(lossModal);
    
    document.getElementById('tournamentLossBtn').addEventListener('click', () => {
        document.body.removeChild(lossModal);
    });
}

        function resetGame() {
    gameState = {
        running: false,
        redScore: 0,
        blueScore: 0,
        timeLeft: 180,
        playerTeam: 'red',
        goalAnimation: false,
        animationTimer: 0,
        goalJustScored: false,
        goalCooldown: 0,
        isOvertime: false,
        isGoldenGoal: false,
        overtimeStarted: false,
        tournament: {
            active: false,
            currentStage: 0,
            playerTeam: null,
            opponentTeam: null,
            stageCompleted: false
        }
    };
    redScoreElem.textContent = '0';
    blueScoreElem.textContent = '0';
    timerElem.textContent = '3:00';
    timerElem.style.display = 'block';
    
    // Скрываем надпись "ДО ЗГ" если она есть
    if (document.getElementById('goldenGoalText')) {
        document.getElementById('goldenGoalText').style.display = 'none';
    }
}

// Переменные для хранения данных команды
let teamName = '';
let teamColor = '';

// Функция для показа модального окна с названием команды
function showTeamNameModal() {
    const modal = document.getElementById('teamNameModal');
    modal.style.display = 'flex';
    
    // Фокус на input при открытии
    setTimeout(() => {
        document.getElementById('teamNameInput').focus();
    }, 100);
}

// Функция для показа модального окна с выбором цвета
function showColorModal() {
    document.getElementById('teamNameModal').style.display = 'none';
    document.getElementById('colorModal').style.display = 'flex';
}

// Функция для применения выбранного цвета ко всей команде
function applyTeamColor(color) {
    teamColor = color;
    
    // Применяем цвет ко всем игрокам команды
    if (gameState.playerTeam === 'red') {
        // Для красной команды
        player.color = color;
        redBots.forEach(bot => {
            bot.color = color;
        });
        // Синяя команда остается с цветом по умолчанию
        blueBots.forEach(bot => {
            bot.color = '#3742fa'; // Синий по умолчанию
        });
    } else {
        // Для синей команды
        player.color = color;
        blueBots.forEach(bot => {
            bot.color = color;
        });
        // Красная команда остается с цветом по умолчанию
        redBots.forEach(bot => {
            bot.color = '#ff4757'; // Красный по умолчанию
        });
    }
    
    console.log(`Цвет команды установлен: ${color}`);
}

// Функция для обновления отрисовки игроков с учетом цвета
function drawPlayerWithColor() {
    // Основной цвет игрока
    ctx.fillStyle = player.color || (gameState.playerTeam === 'red' ? '#ff4757' : '#3742fa');
    ctx.beginPath();
    ctx.arc(player.x, player.y, config.playerRadius, 0, Math.PI * 2);
    ctx.fill();

    // Остальной код отрисовки без изменений...
    ctx.strokeStyle = '#00ff00';
    ctx.lineWidth = 3;
    ctx.stroke();

    const triangleSize = 12;
    const triangleYOffset = -config.playerRadius - 18;
    
    ctx.fillStyle = 'rgba(0, 255, 0, 0.7)';
    ctx.beginPath();
    ctx.moveTo(player.x, player.y + triangleYOffset);
    ctx.lineTo(player.x - triangleSize, player.y + triangleYOffset - triangleSize * 1.5);
    ctx.lineTo(player.x + triangleSize, player.y + triangleYOffset - triangleSize * 1.5);
    ctx.closePath();
    ctx.fill();

    ctx.strokeStyle = '#00ff00';
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(player.x, player.y + triangleYOffset);
    ctx.lineTo(player.x - triangleSize, player.y + triangleYOffset - triangleSize * 1.5);
    ctx.lineTo(player.x + triangleSize, player.y + triangleYOffset - triangleSize * 1.5);
    ctx.closePath();
    ctx.stroke();

    ctx.shadowColor = 'rgba(0, 255, 0, 0.7)';
    ctx.shadowBlur = 15;
    ctx.beginPath();
    ctx.arc(player.x, player.y, config.playerRadius + 2, 0, Math.PI * 2);
    ctx.stroke();
    ctx.shadowBlur = 0;

    if (player.kickCooldown > 0) {
        ctx.strokeStyle = 'rgba(255, 215, 0, 0.8)';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(player.x, player.y, config.playerRadius + 12, 0, Math.PI * 2);
        ctx.stroke();
        
        ctx.shadowColor = 'rgba(255, 215, 0, 0.6)';
        ctx.shadowBlur = 20;
        ctx.beginPath();
        ctx.arc(player.x, player.y, config.playerRadius + 10, 0, Math.PI * 2);
        ctx.stroke();
        ctx.shadowBlur = 0;
    }

    if (player.hasBall) {
        ctx.strokeStyle = 'rgba(255, 255, 0, 0.7)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(player.x, player.y, config.ballControlDistance, 0, Math.PI * 2);
        ctx.stroke();
    }
}

// Функция для отрисовки ботов с учетом цвета
function drawBotsWithColor() {
    // Рисуем красных ботов
    redBots.forEach(bot => {
        // Проверяем, является ли это турнирным противником
        if (gameState.tournament.active && bot.team !== gameState.playerTeam) {
            const opponentColors = gameState.tournament.opponentTeam.colors;
            drawTwoColorPlayer(bot.x, bot.y, config.playerRadius, opponentColors[0], opponentColors[1]);
        } else {
            // Обычный одноцветный бот
            ctx.fillStyle = bot.color || '#ff4757';
            ctx.beginPath();
            ctx.arc(bot.x, bot.y, config.playerRadius, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // Обводка по роли
        ctx.strokeStyle = bot.role === 'goalkeeper' ? 'gold' : 
                         bot.role === 'defender' ? 'cyan' : 'lime';
        ctx.lineWidth = 2;
        ctx.stroke();
    });
    
    // Рисуем синих ботов
    blueBots.forEach(bot => {
        // Проверяем, является ли это турнирным противником
        if (gameState.tournament.active && bot.team !== gameState.playerTeam) {
            const opponentColors = gameState.tournament.opponentTeam.colors;
            drawTwoColorPlayer(bot.x, bot.y, config.playerRadius, opponentColors[0], opponentColors[1]);
        } else {
            // Обычный одноцветный бот
            ctx.fillStyle = bot.color || '#3742fa';
            ctx.beginPath();
            ctx.arc(bot.x, bot.y, config.playerRadius, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // Обводка по роли
        ctx.strokeStyle = bot.role === 'goalkeeper' ? 'gold' : 
                         bot.role === 'defender' ? 'cyan' : 'lime';
        ctx.lineWidth = 2;
        ctx.stroke();
    });
}

function checkAndStartOvertime() {
    if (gameState.timeLeft <= 0 && !gameState.isOvertime && gameState.redScore === gameState.blueScore) {
        gameState.isOvertime = true;
        gameState.isGoldenGoal = true;
        gameState.overtimeStarted = true;
        
        // Скрываем таймер и показываем надпись "ДО ЗГ"
        timerElem.style.display = 'none';
        
        // Создаем элемент для надписи "ДО ЗГ" если его нет
        if (!document.getElementById('goldenGoalText')) {
            const goldenGoalText = document.createElement('div');
            goldenGoalText.id = 'goldenGoalText';
            goldenGoalText.textContent = 'ДО ЗГ';
            goldenGoalText.style.position = 'absolute';
            goldenGoalText.style.top = '30px';
            goldenGoalText.style.left = '50%';
            goldenGoalText.style.transform = 'translateX(-50%)';
            goldenGoalText.style.fontSize = '36px';
            goldenGoalText.style.fontWeight = 'bold';
            goldenGoalText.style.color = 'gold';
            goldenGoalText.style.textShadow = '0 0 10px rgba(255, 215, 0, 0.8)';
            goldenGoalText.style.zIndex = '15';
            document.querySelector('.ui-overlay').appendChild(goldenGoalText);
        } else {
            document.getElementById('goldenGoalText').style.display = 'block';
        }
        
        console.log("Овертайм начался! ДО ЗОЛОТОГО ГОЛА!");
    }
}

        function resetPositions() {
    player.x = gameState.playerTeam === 'red' ? config.width / 4 : config.width * 3 / 4;
    player.y = config.height / 2;
    player.vx = player.vy = 0;
    player.hasBall = false;
    
    // Используем телепортацию вместо прямого присвоения
    teleportBallToCenter();
    
    // Сброс позиций ботов
    initBots();
    
    gameState.goalJustScored = false;
    gameState.goalCooldown = config.goalCooldown;
}

function teleportBallToCenter() {
    ball.x = config.width / 2;
    ball.y = config.height / 2;
    ball.vx = 0;
    ball.vy = 0;
    
    // Сброс таймера AFK
    gameState.ballLastMoveTime = Date.now();
    gameState.ballLastX = ball.x;
    gameState.ballLastY = ball.y;
    
    console.log("Мяч телепортирован в центр из-за бездействия");
}


function initBots() {
    redBots = [];
    blueBots = [];
    
    // Создаем ботов в зависимости от выбранной команды
    if (gameState.playerTeam === 'red') {
        // У красных 2 бота (игрок + 2 бота = 3)
        redBots = [
            createBot('red', 'goalkeeper'),
            createBot('red', 'attacker')
        ];
        // У синих 3 бота
        blueBots = [
            createBot('blue', 'goalkeeper'),
            createBot('blue', 'defender'),
            createBot('blue', 'attacker')
        ];
    } else {
        // У синих 2 бота (игрок + 2 бота = 3)
        blueBots = [
            createBot('blue', 'goalkeeper'),
            createBot('blue', 'attacker')
        ];
        // У красных 3 бота
        redBots = [
            createBot('red', 'goalkeeper'),
            createBot('red', 'defender'),
            createBot('red', 'attacker')
        ];
    }
    
    // Применяем выбранный цвет к своей команде после создания ботов
    if (teamColor) {
        applyTeamColor(teamColor);
    }
    
    // Логируем информацию о ботах для отладки
    console.log("Созданы боты:");
    redBots.forEach((bot, index) => {
        console.log(`Красный бот ${index + 1}: ${bot.isOpponent ? 'Соперник' : 'Союзник'}, скорость: ${bot.speed}`);
    });
    blueBots.forEach((bot, index) => {
        console.log(`Синий бот ${index + 1}: ${bot.isOpponent ? 'Соперник' : 'Союзник'}, скорость: ${bot.speed}`);
    });
}

// Создание бота
function createBot(team, role) {
    const baseX = team === 'red' ? config.width / 4 : config.width * 3 / 4;
    
    // Определяем, является ли этот бот соперником
    const isOpponent = (team === 'red' && gameState.playerTeam === 'blue') || 
                      (team === 'blue' && gameState.playerTeam === 'red');
    
    // Для соперников применяем сложность, для своей команды - базовые значения
    const difficulty = isOpponent ? getCurrentDifficulty() : difficultyLevels[0];
    
    // Определяем цвет бота
    let botColor;
    if (team === 'red') {
        botColor = (gameState.playerTeam === 'red' && teamColor) ? teamColor : '#ff4757';
    } else {
        botColor = (gameState.playerTeam === 'blue' && teamColor) ? teamColor : '#3742fa';
    }
    
    return {
        x: baseX,
        y: config.height / 2,
        vx: 0,
        vy: 0,
        team: team,
        role: role,
        kickCooldown: 0,
        hasBall: false,
        targetX: 0,
        targetY: 0,
        state: 'positioning',
        color: botColor,
        isOpponent: isOpponent, // Добавляем флаг является ли соперником
        // Параметры сложности применяются только к соперникам
        speed: botConfig.speed * difficulty.speedMultiplier,
        kickPower: botConfig.kickPower * difficulty.kickPowerMultiplier,
        reactionTime: botConfig.reactionTime / difficulty.reactionMultiplier,
        errorChance: difficulty.errorChance,
        passAccuracy: difficulty.passAccuracy
    };
}

// Обновление всех ботов
function updateBots() {
    updateBotTeam(redBots);
    updateBotTeam(blueBots);
}

// Функции для звуков
function playKickSound() {
    const kickSound = document.getElementById('kickSound');
    kickSound.currentTime = 0; // Перемотать в начало
    kickSound.play().catch(e => console.log("Audio play error:", e));
}

function playGoalSound() {
    const goalSound = document.getElementById('goalSound');
    goalSound.currentTime = 0; // Перемотать в начало
    goalSound.play().catch(e => console.log("Audio play error:", e));
}

function callForPass() {
    // Определяем, кто является сокомандниками игрока
    let teammates;
    if (gameState.playerTeam === 'red') {
        teammates = redBots;
    } else {
        teammates = blueBots;
    }

    let bestPasser = null;
    let shortestDistance = Infinity;

    // Ищем ближайшего сокомандника, у которого есть мяч
    teammates.forEach(bot => {
        if (bot.hasBall) {
            const distToPlayer = Math.sqrt((bot.x - player.x) ** 2 + (bot.y - player.y) ** 2);
            
            if (distToPlayer < shortestDistance) {
                shortestDistance = distToPlayer;
                bestPasser = bot;
            }
        }
    });

    // Если нашли подходящего пасующего
    if (bestPasser) {
        // Рассчитываем направление паса прямо на игрока
        const passAngle = Math.atan2(player.y - ball.y, player.x - ball.x);
        const power = 8.5; // Четкий резкий пас

        // Задаем новую скорость мячу
        ball.vx = Math.cos(passAngle) * power;
        ball.vy = Math.sin(passAngle) * power;

        // Сбрасываем кулдаун удара у бота
        bestPasser.kickCooldown = 30;
        
        // Визуальный эффект вызова паса (опционально)
        showPassCallEffect(player.x, player.y);
        
        return true;
    }
    
    return false;
}

// Визуальный эффект для вызова паса (круг вокруг игрока)
function showPassCallEffect(x, y) {
    ctx.strokeStyle = '#00ff00';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.arc(x, y, 25, 0, Math.PI * 2);
    ctx.stroke();
    
    ctx.strokeStyle = 'rgba(0, 255, 0, 0.5)';
    ctx.lineWidth = 6;
    ctx.beginPath();
    ctx.arc(x, y, 30, 0, Math.PI * 2);
    ctx.stroke();
}

// Обновление команды ботов
function updateBotTeam(bots) {
    bots.forEach(bot => {
        // Определяем состояние бота
        determineBotState(bot);
        
        // Движение к цели
        moveBotToTarget(bot);
        
        // Взаимодействие с мячом
        handleBotBallInteraction(bot);
        
        // Применяем трение
        bot.vx *= 0.9;
        bot.vy *= 0.9;
        
        // Обновляем позицию
        bot.x += bot.vx;
        bot.y += bot.vy;
        
        // Границы поля
        bot.x = Math.max(config.playerRadius, Math.min(config.width - config.playerRadius, bot.x));
        bot.y = Math.max(config.playerRadius, Math.min(config.height - config.playerRadius, bot.y));
        
        // Обновляем кулдаун
        if (bot.kickCooldown > 0) bot.kickCooldown--;
    });
}

// Определение состояния бота
function determineBotState(bot) {
    const distToBall = Math.sqrt((ball.x - bot.x) ** 2 + (ball.y - bot.y) ** 2);
    const ballInMyHalf = (bot.team === 'red' && ball.x < config.width / 2) || 
                         (bot.team === 'blue' && ball.x > config.width / 2);
    
    switch (bot.role) {
        case 'goalkeeper':
            // Вратарь может двигаться горизонтально в сторону своих ворот
            const goalX = bot.team === 'red' ? 0 : config.width;
            const goalY = config.height / 2;
            
            // Определяем зону движения вратаря (горизонтальная линия перед воротами)
            const keeperZoneX = bot.team === 'red' ? 80 : config.width - 80;
            const keeperZoneMinX = bot.team === 'red' ? 40 : config.width - 120;
            const keeperZoneMaxX = bot.team === 'red' ? 120 : config.width - 40;
            
            // Если мяч на нашей половине - преследуем его по горизонтали
            if (ballInMyHalf) {
                bot.targetX = Math.max(keeperZoneMinX, Math.min(keeperZoneMaxX, ball.x));
                bot.targetY = ball.y;
                bot.state = 'chasing';
            } else {
                // Возвращаемся на позицию перед воротами
                bot.targetX = keeperZoneX;
                bot.targetY = goalY;
                bot.state = 'positioning';
            }
            break;
            
        case 'defender':
            // Защитник играет на своей половине
            bot.targetX = bot.team === 'red' ? config.width / 3 : config.width * 2 / 3;
            bot.targetY = ball.y;
            bot.state = ballInMyHalf ? 'chasing' : 'positioning';
            break;
            
        case 'attacker':
            // Нападающий атакует
            if (distToBall < 150) {
                bot.state = 'chasing';
                bot.targetX = ball.x;
                bot.targetY = ball.y;
            } else {
                bot.state = 'attacking';
                // Занимает позицию для атаки
                bot.targetX = bot.team === 'red' ? config.width * 2 / 3 : config.width / 3;
                bot.targetY = Math.random() * config.height;
            }
            break;
    }
}

// Движение бота к цели
function moveBotToTarget(bot) {
    const dx = bot.targetX - bot.x;
    const dy = bot.targetY - bot.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    
    if (dist > 10) {
        const speed = bot.speed * (bot.state === 'chasing' ? 1.2 : 0.8);
        bot.vx += (dx / dist) * speed * 0.1;
        bot.vy += (dy / dist) * speed * 0.1;
    }
}

// Взаимодействие бота с мячом
function handleBotBallInteraction(bot) {
    const dist = Math.sqrt((ball.x - bot.x) ** 2 + (ball.y - bot.y) ** 2);
    const minDist = config.playerRadius + config.ballRadius;
    
    bot.hasBall = dist < config.ballControlDistance + 10;
    
    if (dist < minDist) {
        const angle = Math.atan2(ball.y - bot.y, ball.x - bot.x);
        const overlap = minDist - dist;
        
        // Сдвигаем мяч
        ball.x += Math.cos(angle) * overlap;
        ball.y += Math.sin(angle) * overlap;
        
        // Боты лучше контролируют мяч (в зависимости от уровня)
        if (bot.kickCooldown <= 0) {
            const controlStrength = botConfig.ballControl * (1 - bot.errorChance / 2);
            ball.vx += (bot.vx - ball.vx) * controlStrength;
            ball.vy += (bot.vy - ball.vy) * controlStrength;
        }
        
        // Удар по мячу с учетом сложности
        if (bot.kickCooldown <= 0 && Math.random() < (0.3 + (1 - bot.errorChance) * 0.4)) {
            let targetX, targetY;
            
            if (bot.role === 'goalkeeper') {
                // Вратарь отдает пас защитнику или нападающему
                const teammates = bot.team === 'red' ? redBots : blueBots;
                const availableTeammates = teammates.filter(t => t.role !== 'goalkeeper');
                if (availableTeammates.length > 0) {
                    const target = availableTeammates[Math.floor(Math.random() * availableTeammates.length)];
                    targetX = target.x;
                    targetY = target.y;
                } else {
                    targetX = config.width / 2;
                    targetY = config.height / 2;
                }
            } else {
                // Атака или пас с учетом точности
                if (Math.random() < (0.7 - bot.errorChance * 0.3) && bot.role === 'attacker') {
                    // Атака на ворота (более точная у сильных ботов)
                    targetX = bot.team === 'red' ? config.width - 50 : 50;
                    targetY = config.height / 2 + (Math.random() - 0.5) * (100 - bot.passAccuracy * 30);
                } else {
                    // Пас партнеру (более точный у сильных ботов)
                    const teammates = bot.team === 'red' ? [...redBots, player.team === 'red' ? player : null] : 
                                                            [...blueBots, player.team === 'blue' ? player : null];
                    const validTeammates = teammates.filter(t => t && t !== bot);
                    if (validTeammates.length > 0) {
                        const target = validTeammates[Math.floor(Math.random() * validTeammates.length)];
                        // Добавляем случайность в зависимости от точности
                        targetX = target.x + (Math.random() - 0.5) * (50 - bot.passAccuracy * 40);
                        targetY = target.y + (Math.random() - 0.5) * (50 - bot.passAccuracy * 40);
                    } else {
                        targetX = config.width / 2;
                        targetY = config.height / 2;
                    }
                }
            }
            
            const kickAngle = Math.atan2(targetY - ball.y, targetX - ball.x);
            const power = bot.kickPower;
            ball.vx += Math.cos(kickAngle) * power;
            ball.vy += Math.sin(kickAngle) * power;
            bot.kickCooldown = 11 / bot.reactionTime;
            playKickSound();
        }
    }
}

// Отрисовка ботов
function drawBots() {
    // Рисуем красных ботов
    redBots.forEach(bot => {
        ctx.fillStyle = '#ff4757';
        ctx.beginPath();
        ctx.arc(bot.x, bot.y, config.playerRadius, 0, Math.PI * 2);
        ctx.fill();
        
        // Обводка по роли
        ctx.strokeStyle = bot.role === 'goalkeeper' ? 'gold' : 
                         bot.role === 'defender' ? 'cyan' : 'lime';
        ctx.lineWidth = 2;
        ctx.stroke();
    });
    
    // Рисуем синих ботов
    blueBots.forEach(bot => {
        ctx.fillStyle = '#3742fa';
        ctx.beginPath();
        ctx.arc(bot.x, bot.y, config.playerRadius, 0, Math.PI * 2);
        ctx.fill();
        
        // Обводка по роли
        ctx.strokeStyle = bot.role === 'goalkeeper' ? 'gold' : 
                         bot.role === 'defender' ? 'cyan' : 'lime';
        ctx.lineWidth = 2;
        ctx.stroke();
    });
}


        function updatePlayer() {
    // Движение
    let dx = 0, dy = 0;
    if (keys.w) dy -= 1;
    if (keys.s) dy += 1;
    if (keys.a) dx -= 1;
    if (keys.d) dx += 1;
    
    // Вызов паса по нажатию Q
    if (keys.q) {
        callForPass();
        keys.q = false; // Сбрасываем флаг после обработки
    }

    // Нормализация диагонального движения
    if (dx !== 0 && dy !== 0) {
        const len = Math.sqrt(dx * dx + dy * dy);
        dx /= len;
        dy /= len;
    }

    player.vx = dx * config.playerSpeed;
    player.vy = dy * config.playerSpeed;

    // Обновление позиции
    player.x += player.vx;
    player.y += player.vy;

    // Границы поля
    player.x = Math.max(config.playerRadius, Math.min(config.width - config.playerRadius, player.x));
    player.y = Math.max(config.playerRadius, Math.min(config.height - config.playerRadius, player.y));

    // Взаимодействие с мячом
    const dist = Math.sqrt((ball.x - player.x) ** 2 + (ball.y - player.y) ** 2);
    const minDist = config.playerRadius + config.ballRadius;
    
    // Убрана проверка контроля мяча (магнетизм)
    player.hasBall = false;
    
    if (dist < minDist) {
        const angle = Math.atan2(ball.y - player.y, ball.x - player.x);
        const overlap = minDist - dist;
        
        // Сдвигаем мяч
        ball.x += Math.cos(angle) * overlap;
        ball.y += Math.sin(angle) * overlap;
        
        // Двусторонняя физика - мяч тоже толкает игрока
        const ballMass = 0.4; // Масса мяча относительно игрока
        player.x -= Math.cos(angle) * overlap * ballMass;
        player.y -= Math.sin(angle) * overlap * ballMass;
        
        // Передача импульса от мяча к игроку
        const impactStrength = 0.2; // Сила воздействия мяча на игрока
        player.vx += ball.vx * impactStrength;
        player.vy += ball.vy * impactStrength;
        
        // УБРАН магнетизм - мяч не следует за игроком
        // Остается только физическое столкновение
    }

    // Удар
if (keys.space && player.kickCooldown <= 0) {
    if (dist < minDist + 10) {
        const angle = Math.atan2(ball.y - player.y, ball.x - player.x);
        const power = config.kickPower;
        ball.vx += Math.cos(angle) * power;
        ball.vy += Math.sin(angle) * power;
        player.kickCooldown = 7;
        playKickSound(); // Добавьте эту строку
    }
}

    if (player.kickCooldown > 0) player.kickCooldown--;
    
    // Обработка задержки после гола
    if (gameState.goalCooldown > 0) {
        gameState.goalCooldown--;
    }
}
function updateBall() {
    // Проверка движения мяча
    const currentTime = Date.now();
    const movedX = Math.abs(ball.x - gameState.ballLastX) > 0.5;
    const movedY = Math.abs(ball.y - gameState.ballLastY) > 0.5;
    
    if (movedX || movedY) {
        // Мяч двигался - обновляем время и позицию
        gameState.ballLastMoveTime = currentTime;
        gameState.ballLastX = ball.x;
        gameState.ballLastY = ball.y;
    } else if (currentTime - gameState.ballLastMoveTime > config.ballAfkThreshold) {
        // Мяч не двигался дольше порога - телепортируем в центр
        teleportBallToCenter();
    }
    
    // Движение мяча
    ball.x += ball.vx;
    ball.y += ball.vy;

    // Реалистичное замедление мяча с учетом времени
    const currentSpeed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
    
    if (currentSpeed > 0.1) {
        // Базовое трение (воздушное сопротивление)
        const airResistance = 0.99;
        
        // Дополнительное трение от поверхности (чем быстрее мяч, тем больше трение)
        const surfaceFriction = 0.995 - (currentSpeed * 0.0001);
        
        // Комбинированный коэффициент замедления
        const combinedFriction = airResistance * surfaceFriction;
        
        // Применяем замедление
        ball.vx *= combinedFriction;
        ball.vy *= combinedFriction;
        
        // Минимальная скорость - остановка почти полностью
        if (Math.abs(ball.vx) < 0.05) ball.vx = 0;
        if (Math.abs(ball.vy) < 0.05) ball.vy = 0;
    } else {
        // Полная остановка
        ball.vx = 0;
        ball.vy = 0;
    }

    // Отскок от стен (кроме зоны ворот)
    if (ball.y - config.ballRadius < 0 || ball.y + config.ballRadius > config.height) {
        ball.vy = -ball.vy * 0.9;
        ball.y = Math.max(config.ballRadius, Math.min(config.height - config.ballRadius, ball.y));
    }
    
    // Отскок от боковых стен (только вне зоны ворот)
    const goalTop = (config.height - config.goalHeight) / 2;
    const goalBottom = (config.height + config.goalHeight) / 2;
    
    // Левая стена (кроме ворот)
    if (ball.x - config.ballRadius < 0) {
        if (ball.y < goalTop || ball.y > goalBottom) {
            ball.vx = -ball.vx * 0.9;
            ball.x = config.ballRadius;
        }
    }
    
    // Правая стена (кроме ворот)
    if (ball.x + config.ballRadius > config.width) {
        if (ball.y < goalTop || ball.y > goalBottom) {
            ball.vx = -ball.vx * 0.9;
            ball.x = config.width - config.ballRadius;
        }
    }

    // Проверка голов (только если не было недавно гола)
    if (gameState.goalCooldown <= 0) {
        checkGoals();
    }
}

function checkPlayerBotCollisions() {
    // Проверка столкновений игрока с ботами
    const allBots = [...redBots, ...blueBots];
    
    allBots.forEach(bot => {
        const dist = Math.sqrt((player.x - bot.x) ** 2 + (player.y - bot.y) ** 2);
        const minDist = config.playerRadius * 2;
        
        if (dist < minDist) {
            const angle = Math.atan2(player.y - bot.y, player.x - bot.x);
            const overlap = minDist - dist;
            
            // Сдвигаем обоих объектов
            const moveRatio = 0.5; // Распределение силы отталкивания
            
            player.x += Math.cos(angle) * overlap * moveRatio;
            player.y += Math.sin(angle) * overlap * moveRatio;
            
            bot.x -= Math.cos(angle) * overlap * moveRatio;
            bot.y -= Math.sin(angle) * overlap * moveRatio;
            
            // Обмен импульсами (физика столкновения)
            const playerMass = 1.0;
            const botMass = 0.8;
            const totalMass = playerMass + botMass;
            
            const playerVx = player.vx;
            const playerVy = player.vy;
            const botVx = bot.vx;
            const botVy = bot.vy;
            
            // Новые скорости после столкновения
            player.vx = (playerVx * (playerMass - botMass) + 2 * botMass * botVx) / totalMass * 0.7;
            player.vy = (playerVy * (playerMass - botMass) + 2 * botMass * botVy) / totalMass * 0.7;
            
            bot.vx = (botVx * (botMass - playerMass) + 2 * playerMass * playerVx) / totalMass * 0.7;
            bot.vy = (botVy * (botMass - playerMass) + 2 * playerMass * playerVy) / totalMass * 0.7;
        }
    });
}

function checkBotBotCollisions() {
    // Проверка столкновений между ботами одной команды
    checkTeamBotCollisions(redBots);
    checkTeamBotCollisions(blueBots);
    
    // Проверка столкновений между ботами разных команд
    redBots.forEach(redBot => {
        blueBots.forEach(blueBot => {
            const dist = Math.sqrt((redBot.x - blueBot.x) ** 2 + (redBot.y - blueBot.y) ** 2);
            const minDist = config.playerRadius * 2;
            
            if (dist < minDist) {
                const angle = Math.atan2(redBot.y - blueBot.y, redBot.x - blueBot.x);
                const overlap = minDist - dist;
                
                // Сдвигаем обоих ботов
                const moveRatio = 0.5;
                
                redBot.x += Math.cos(angle) * overlap * moveRatio;
                redBot.y += Math.sin(angle) * overlap * moveRatio;
                
                blueBot.x -= Math.cos(angle) * overlap * moveRatio;
                blueBot.y -= Math.sin(angle) * overlap * moveRatio;
                
                // Обмен импульсами
                const redMass = 0.8;
                const blueMass = 0.8;
                const totalMass = redMass + blueMass;
                
                const redVx = redBot.vx;
                const redVy = redBot.vy;
                const blueVx = blueBot.vx;
                const blueVy = blueBot.vy;
                
                redBot.vx = (redVx * (redMass - blueMass) + 2 * blueMass * blueVx) / totalMass * 0.7;
                redBot.vy = (redVy * (redMass - blueMass) + 2 * blueMass * blueVy) / totalMass * 0.7;
                
                blueBot.vx = (blueVx * (blueMass - redMass) + 2 * redMass * redVx) / totalMass * 0.7;
                blueBot.vy = (blueVy * (blueMass - redMass) + 2 * redMass * redVy) / totalMass * 0.7;
            }
        });
    });
}

function checkTeamBotCollisions(bots) {
    // Проверка столкновений между ботами одной команды
    for (let i = 0; i < bots.length; i++) {
        for (let j = i + 1; j < bots.length; j++) {
            const bot1 = bots[i];
            const bot2 = bots[j];
            
            const dist = Math.sqrt((bot1.x - bot2.x) ** 2 + (bot1.y - bot2.y) ** 2);
            const minDist = config.playerRadius * 2;
            
            if (dist < minDist) {
                const angle = Math.atan2(bot1.y - bot2.y, bot1.x - bot2.x);
                const overlap = minDist - dist;
                
                // Сдвигаем обоих ботов
                const moveRatio = 0.5;
                
                bot1.x += Math.cos(angle) * overlap * moveRatio;
                bot1.y += Math.sin(angle) * overlap * moveRatio;
                
                bot2.x -= Math.cos(angle) * overlap * moveRatio;
                bot2.y -= Math.sin(angle) * overlap * moveRatio;
                
                // Обмен импульсами
                const mass1 = 0.8;
                const mass2 = 0.8;
                const totalMass = mass1 + mass2;
                
                const vx1 = bot1.vx;
                const vy1 = bot1.vy;
                const vx2 = bot2.vx;
                const vy2 = bot2.vy;
                
                bot1.vx = (vx1 * (mass1 - mass2) + 2 * mass2 * vx2) / totalMass * 0.7;
                bot1.vy = (vy1 * (mass1 - mass2) + 2 * mass2 * vy2) / totalMass * 0.7;
                
                bot2.vx = (vx2 * (mass2 - mass1) + 2 * mass1 * vx1) / totalMass * 0.7;
                bot2.vy = (vy2 * (mass2 - mass1) + 2 * mass1 * vy1) / totalMass * 0.7;
            }
        }
    }
}

        function checkGoals() {
    if (gameState.goalCooldown <= 0) {
        const goalTop = (config.height - config.goalHeight) / 2;
        const goalBottom = (config.height + config.goalHeight) / 2;
        
        // Левые ворота
        if (ball.x + config.ballRadius < 0 && ball.y > goalTop && ball.y < goalBottom) {
            gameState.blueScore++;
            blueScoreElem.textContent = gameState.blueScore;
            showGoalAnimation();
            playGoalSound();
            gameState.goalJustScored = true;
            gameState.goalCooldown = config.goalCooldown;
            
            // Если в овертайме - сразу заканчиваем игру
            if (gameState.isOvertime) {
                setTimeout(() => {
                    endGame(); // Завершаем игру после гола в овертайме
                }, 2000);
            } else {
                setTimeout(() => {
                    resetPositions();
                    initBots();
                }, 2000);
            }
        }
        
        // Правые ворота
        if (ball.x - config.ballRadius > config.width && ball.y > goalTop && ball.y < goalBottom) {
            gameState.redScore++;
            redScoreElem.textContent = gameState.redScore;
            showGoalAnimation();
            playGoalSound();
            gameState.goalJustScored = true;
            gameState.goalCooldown = config.goalCooldown;
            
            // Если в овертайме - сразу заканчиваем игру
            if (gameState.isOvertime) {
                setTimeout(() => {
                    endGame(); // Завершаем игру после гола в овертайме
                }, 2000);
            } else {
                setTimeout(() => {
                    resetPositions();
                    initBots();
                }, 2000);
            }
        }
    }
}

        function showGoalAnimation() {
            gameState.goalAnimation = true;
            gameState.animationTimer = 120;
            goalAnimationElem.style.animation = 'none';
            void goalAnimationElem.offsetWidth;
            goalAnimationElem.style.animation = 'goalPulse 2s ease-out';
        }

        function updateTimer() {
    if (gameState.timeLeft > 0) {
        gameState.timeLeft--;
        const minutes = Math.floor(gameState.timeLeft / 60);
        const seconds = gameState.timeLeft % 60;
        timerElem.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
        
        if (gameState.timeLeft === 0) {
            checkAndStartOvertime(); // Проверяем и начинаем овертайм если нужно
            if (!gameState.isOvertime) {
                endGame(); // Заканчиваем игру если овертайм не нужен
            }
        }
    }
}

        function endGame() {
    // Проверяем, нужно ли начинать овертайм
    if (gameState.timeLeft <= 0 && gameState.redScore === gameState.blueScore && !gameState.isOvertime) {
        checkAndStartOvertime();
        return; // Не заканчиваем игру, начинаем овертайм
    }
    
    // Если овертайм активен и забит гол, заканчиваем игру
    if (gameState.isOvertime && (gameState.redScore !== gameState.blueScore)) {
        gameState.running = false;
        
        // Проверяем, активен ли турнирный режим
        if (gameState.tournament.active) {
            const isWin = (gameState.playerTeam === 'red' && gameState.redScore > gameState.blueScore) ||
                         (gameState.playerTeam === 'blue' && gameState.blueScore > gameState.redScore);
            
            handleMatchResult(isWin);
        } else {
            // Показываем окно "ИГРА ОКОНЧЕНА!" только если НЕ турнирный режим
            finalScoreElem.textContent = `${gameState.redScore} - ${gameState.blueScore}`;
            gameOverElem.style.display = 'block';
        }
        
        return;
    }
    
    // Обычное окончание игры (без овертайма или после овертайма с голом)
    if (!gameState.isOvertime || (gameState.isOvertime && gameState.redScore !== gameState.blueScore)) {
        gameState.running = false;
        
        // Проверяем, активен ли турнирный режим
        if (gameState.tournament.active) {
            const isWin = (gameState.playerTeam === 'red' && gameState.redScore > gameState.blueScore) ||
                         (gameState.playerTeam === 'blue' && gameState.blueScore > gameState.redScore);
            
            handleMatchResult(isWin);
        } else {
            // Показываем окно "ИГРА ОКОНЧЕНА!" только если НЕ турнирный режим
            finalScoreElem.textContent = `${gameState.redScore} - ${gameState.blueScore}`;
            gameOverElem.style.display = 'block';
        }
    }
}

        function drawField() {
            // Поле
            ctx.fillStyle = '#2c3e50';
            ctx.fillRect(0, 0, config.width, config.height);

            // Центральная линия
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(config.width / 2, 0);
            ctx.lineTo(config.width / 2, config.height);
            ctx.stroke();

            // Центральный круг
            ctx.beginPath();
            ctx.arc(config.width / 2, config.height / 2, 50, 0, Math.PI * 2);
            ctx.stroke();

            // Ворота
            const goalTop = (config.height - config.goalHeight) / 2;
            const goalBottom = (config.height + config.goalHeight) / 2;
            
            // Левые ворота
            ctx.strokeStyle = '#ff4757';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(0, goalTop);
            ctx.lineTo(0, goalBottom);
            ctx.stroke();
            
            // Правые ворота
            ctx.strokeStyle = '#3742fa';
            ctx.beginPath();
            ctx.moveTo(config.width, goalTop);
            ctx.lineTo(config.width, goalBottom);
            ctx.stroke();
            
            // Сетка ворот
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.setLineDash([5, 5]);
            
            // Левая сетка
            ctx.beginPath();
            ctx.moveTo(0, goalTop);
            ctx.lineTo(-20, goalTop);
            ctx.moveTo(0, goalBottom);
            ctx.lineTo(-20, goalBottom);
            ctx.stroke();
            
            // Правая сетка
            ctx.beginPath();
            ctx.moveTo(config.width, goalTop);
            ctx.lineTo(config.width + 20, goalTop);
            ctx.moveTo(config.width, goalBottom);
            ctx.lineTo(config.width + 20, goalBottom);
            ctx.stroke();
            
            ctx.setLineDash([]);
        }

        function drawPlayer() {
    // Основной цвет игрока
    ctx.fillStyle = gameState.playerTeam === 'red' ? '#ff4757' : '#3742fa';
    ctx.beginPath();
    ctx.arc(player.x, player.y, config.playerRadius, 0, Math.PI * 2);
    ctx.fill();

    // Яркая обводка игрока (толстая и контрастная)
    ctx.strokeStyle = '#00ff00'; // Ярко-зеленый цвет
    ctx.lineWidth = 3;
    ctx.stroke();

    // Треугольный индикатор над игроком (полупрозрачный)
    const triangleSize = 12;
    const triangleYOffset = -config.playerRadius - 18;
    
    ctx.fillStyle = 'rgba(0, 255, 0, 0.7)'; // Полупрозрачный зеленый
    ctx.beginPath();
    ctx.moveTo(player.x, player.y + triangleYOffset);
    ctx.lineTo(player.x - triangleSize, player.y + triangleYOffset - triangleSize * 1.5);
    ctx.lineTo(player.x + triangleSize, player.y + triangleYOffset - triangleSize * 1.5);
    ctx.closePath();
    ctx.fill();

    // Обводка треугольника для лучшей видимости
    ctx.strokeStyle = '#00ff00';
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(player.x, player.y + triangleYOffset);
    ctx.lineTo(player.x - triangleSize, player.y + triangleYOffset - triangleSize * 1.5);
    ctx.lineTo(player.x + triangleSize, player.y + triangleYOffset - triangleSize * 1.5);
    ctx.closePath();
    ctx.stroke();

    // Свечение вокруг игрока
    ctx.shadowColor = 'rgba(0, 255, 0, 0.7)';
    ctx.shadowBlur = 15;
    ctx.beginPath();
    ctx.arc(player.x, player.y, config.playerRadius + 2, 0, Math.PI * 2);
    ctx.stroke();
    ctx.shadowBlur = 0; // Сбрасываем тень

    // Увеличенный индикатор удара
    if (player.kickCooldown > 0) {
        ctx.strokeStyle = 'rgba(255, 215, 0, 0.8)'; // Золотой цвет
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(player.x, player.y, config.playerRadius + 12, 0, Math.PI * 2); // Увеличенный радиус
        ctx.stroke();
        
        // Дополнительное свечение при ударе
        ctx.shadowColor = 'rgba(255, 215, 0, 0.6)';
        ctx.shadowBlur = 20;
        ctx.beginPath();
        ctx.arc(player.x, player.y, config.playerRadius + 10, 0, Math.PI * 2);
        ctx.stroke();
        ctx.shadowBlur = 0;
    }

    // Индикатор контроля мяча (если нужно)
    if (player.hasBall) {
        ctx.strokeStyle = 'rgba(255, 255, 0, 0.7)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(player.x, player.y, config.ballControlDistance, 0, Math.PI * 2);
        ctx.stroke();
    }
}

        function drawBall() {
            // Мяч
            ctx.fillStyle = '#f1c40f';
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, config.ballRadius, 0, Math.PI * 2);
            ctx.fill();

            // Черные пятиугольники
            ctx.fillStyle = '#000';
            for (let i = 0; i < 5; i++) {
                const angle = (i * Math.PI * 2 / 5) + Date.now() / 1000;
                const pentX = ball.x + Math.cos(angle) * config.ballRadius * 0.6;
                const pentY = ball.y + Math.sin(angle) * config.ballRadius * 0.6;
                ctx.beginPath();
                ctx.arc(pentX, pentY, config.ballRadius * 0.2, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function gameLoop() {
    if (!gameState.running) return;

    updatePlayer();
    updateBots();
    updateBall();
    
    checkPlayerBotCollisions();
    checkBotBotCollisions();

    drawField();
    drawPlayerWithColor(); // Заменяем на новую функцию
    drawBotsWithColor();   // Заменяем на новую функцию
    drawBall();

    requestAnimationFrame(gameLoop);
}

        // Запуск таймера
        setInterval(() => {
            if (gameState.running) {
                updateTimer();
            }
        }, 1000);

        // Начальная отрисовка
        drawField();

// Функционал кнопки "Об игре"
const aboutBtn = document.getElementById('aboutBtn');
const aboutModal = document.getElementById('aboutModal');
const overlay = document.getElementById('overlay');
const closeBtn = document.querySelector('.close-btn');

function openAboutModal() {
    aboutModal.style.display = 'block';
    overlay.style.display = 'block';
    gameState.running = false;
}

function closeAboutModal() {
    aboutModal.style.display = 'none';
    overlay.style.display = 'none';
    if (!teamMenu.style.display === 'block' && !gameOverElem.style.display === 'block') {
        gameState.running = true;
        gameLoop();
    }
}

aboutBtn.addEventListener('click', openAboutModal);
closeBtn.addEventListener('click', closeAboutModal);
overlay.addEventListener('click', closeAboutModal);

// Закрытие по ESC
document.addEventListener('keydown', (e) => {
    if (e.code === 'Escape' && aboutModal.style.display === 'block') {
        closeAboutModal();
    }
});

// Обработчики для модальных окон
document.getElementById('teamNameSubmit').addEventListener('click', () => {
    const teamNameInput = document.getElementById('teamNameInput');
    if (teamNameInput.value.trim()) {
        teamName = teamNameInput.value.trim();
        showColorModal();
    }
});

document.getElementById('teamNameInput').addEventListener('keypress', (e) => {
    if (e.key === 'Enter') {
        document.getElementById('teamNameSubmit').click();
    }
});

// Обработчики для выбора цвета
document.querySelectorAll('.color-option').forEach(option => {
    option.addEventListener('click', () => {
        // Убираем выделение со всех options
        document.querySelectorAll('.color-option').forEach(opt => {
            opt.classList.remove('selected');
        });
        
        // Выделяем выбранный option
        option.classList.add('selected');
        
        // Сохраняем выбранный цвет
        const selectedColor = option.getAttribute('data-color');
        applyTeamColor(selectedColor);
    });
});

document.getElementById('colorSubmit').addEventListener('click', () => {
    document.getElementById('colorModal').style.display = 'none';
    teamMenu.style.display = 'block';
});

// Показываем модальное окно при загрузке
window.addEventListener('load', () => {
    setTimeout(showTeamNameModal, 500);
});
    </script>
</body>
</html>
